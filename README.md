# Solar export automation and house consumption (ESPHome/Node-Red)
Lucky for me, my electricity company provides wholesale pricing, although comes with a risk of extremely low (or negative) import prices. Amber Electric also offers an API and Home Assistant integration for current & forecast pricing - which gave me some hope to automate the limit of energy being generated by my solar inverter.
## Hardware
**ESPHome (ESP32)**
I'm using a single ESP32 running ESPHome to monitor the house power consumption with two methods; 1x current transformer sensor (SCT-013-030 30A/1V), and counting the LED pulses on the electricity meter for imported energy. There is a benefit to using an ESP32 over the ESP8266 when measuring analog values like we will be doing, as it has 12-bit ADC resolution (4096 bits) compared to the ESP8266 with 10-bit (1024 bits). That's 4x the resolution for a few more dollars. [Product link](https://www.jaycar.com.au/esp32-main-board-with-wifi-and-bluetooth-communication/p/XC3800)

**GoodWe GW5000D-NS Solar Inverter**
It's important that this inverter is on the latest DSP and ARM firmware. The GoodWe customer support person said that she was unable to complete the update for me, but provided me the number for GoodWe technical support, and they were able to complete it once I provided the S/N of the inverter (and connected to SEMS). It took about 15 minutes to complete the update after that call.

**Current Transformer Sensor (YHDC SCT-013-030)**
This model of current transformer has a built-in burden resistor and outputs 0-1V for the ESP32 to read 0-30A (7kW @ 240V) of AC current. [Product link](https://core-electronics.com.au/non-invasive-ac-current-sensor-30a-max-seeed-studio.html)

**Light Dependent Resistor (LDR sensor)**
An LDR outputs a signal based on the light available to the sensor, which we can use in ESPHome to count the pulses from an energy meter's LED for imp/Wh and calculate the imported energy. [Product link](https://www.jaycar.com.au/small-light-dependent-resistor-ldr/p/RD3480)
## Setup
My microcontroller is currently still sitting on a breadboard, although I'm planning to turn it into a PCB at some point and 3D print an enclosure for it to sit in.

**Current Transformer**
The CT sensor itself is pretty easy to connect to the ESP32. As it has the burden resistor built in, we only need a voltage divider. If you're using something like the YHDC SCT-013-000 which outputs 0-50mA for 0-100A (24kW @ 240V), you'll have to [calculate the correct burden resistor size](https://learn.openenergymonitor.org/electricity-monitoring/ct-sensors/interface-with-arduino) and add that to your voltage divider.

Since we don't need to do that, the circuit looks like this:
![](https://i.imgur.com/bDyinCT.png)
The resistor sizes for R1 & R2 don't matter all that much as long as they match, and are anywhere between 10K-470KΩ. I used 2x 100KΩ in my setup. ADC IN on the above diagram goes to pin D35 for me (and the code in this project, but we'll get to that later). 

**LDR**
I originally based this part of the configuration off of the [Home Assistant Glow](https://github.com/klaasnicolaas/home-assistant-glow) project, however that uses a (hard to find where I am) [photodiode](https://www.aliexpress.com/item/1005001640685908.html?af=417111&afref=https%3A%2F%2Fgithub.com%2Fklaasnicolaas%2Fhome-assistant-glow&cv=12&dp=12%3A%3A417111%3A%3A%3A%3A%3A%3A1665722953&cn=15640&aff_fcid=7d64ae58797f4fa7afca02df763e78c4-1665722953571-02185-Y7bAZbY&aff_fsk=Y7bAZbY&aff_platform=aaf&sk=Y7bAZbY&aff_trace_key=7d64ae58797f4fa7afca02df763e78c4-1665722953571-02185-Y7bAZbY&terminal_id=4f2160c9413243e29b22d0648101c9c1&afSmartRedirect=y). If these are easy to find for you, it may be easier to go that way, however I haven't had a single issue with this setup.

This part of the circuit looks like this. The LDR symbol in this schematic is an LED, although the orientation of the LDR pins doesn't matter:
![](https://i.imgur.com/ySvODhv.png)
We also need to bridge pins D18 and D19 together as there is a binary sensor toggle in the ESPHome config that switches these pins based on the LED pulses.

**Solar Inverter**
There's a GoodWe HACS integration that provides local polling access to the inverter, however for the DNS series inverter that I have, the grid export function wasn't working. I had to modify the python for this integration to enable this function as it wasn't correctly identifying the model. 

This can be found in /custom_components/goodwe/number.py and changing the "NUMBERS" section to:
```
NUMBERS = (
    GoodweNumberEntityDescription(
        key="grid_export_limit",
        name="Grid export limit",
        icon="mdi:transmission-tower",
        entity_category=EntityCategory.CONFIG,
        native_unit_of_measurement=POWER_WATT,
        native_step=100,
        native_min_value=0,
        native_max_value=5000,
        getter=lambda inv: inv.get_grid_export_limit(),
        setter=lambda inv, val: inv.set_grid_export_limit(val+200),
        filter=lambda inv: True,
    ),
    GoodweNumberEntityDescription(
        key="battery_discharge_depth",
        name="Depth of discharge (on-grid)",
        icon="mdi:battery-arrow-down",
        entity_category=EntityCategory.CONFIG,
        native_unit_of_measurement=PERCENTAGE,
        native_step=1,
        native_min_value=0,
        native_max_value=99,
        getter=lambda inv: inv.get_ongrid_battery_dod(),
        setter=lambda inv, val: inv.set_ongrid_battery_dod(val),
        filter=lambda inv: True,
    ),
    GoodweNumberEntityDescription(
        key="eco_mode_power",
        name="Eco mode power",
        icon="mdi:battery-charging-low",
        entity_category=EntityCategory.CONFIG,
        native_unit_of_measurement=PERCENTAGE,
        native_step=1,
        native_min_value=0,
        native_max_value=100,
        getter=lambda inv: inv.get_operation_mode(),
        setter=None,
        filter=lambda inv: True,
    ),
)
```
In the config above you can see I have added a 200W buffer on Line 12, this is because when the export was set to 1000W in HA, it would actually set to 800W, etc. This does mean that setting the inverter to 0W actually sets it to 200W, but that scenario was pretty infrequent for me.

**ESPHome**
After installing ESPHome onto the ESP32 and adding it to my Home Assistant instance, this configuration below is what I'm using for the sensors:
```
---
# Pulse counter for energy monitoring
substitutions:
  device_name: esphome-energy-monitor
  friendly_name: Energy monitor
  device_description: "ESP32 for energy monitoring"
  ipulse_pin: GPIO12
  pulse_rate: '1000' # imp/kWh rate
  web_username: 'glow'

dashboard_import:
  package_import_url: github://klaasnicolaas/home-assistant-glow/home_assistant_glow.yaml

esphome:
  name: '${device_name}'
  comment: '${device_description}'
  platform: ESP32
  board: nodemcu-32s

# Wifi credentials
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap: # Enable fallback hotspot (captive portal) in case wifi connection fails
    ssid: '${device_name}'
    password: !secret wifi_password

captive_portal:
logger: # Enable logging
improv_serial: # Enable improv over serial

# Enable Home Assistant API
api:
  services:
    - service: reset_total_import_energy
      then:
        - button.press:
            id: button_reset_import_total

# Enable OTA updates
ota:
  safe_mode: true
  reboot_timeout: 10min
  num_attempts: 5

# Enable web interface
web_server:
  port: 80
  auth:
    username: '${web_username}'
    password: !secret wifi_password

# Add reset button for testing
button:
  - platform: restart
    name: "Restart - Glow"
  - platform: template
    name: "Reset - Energy Import"
    id: button_reset_import_total
    on_press:
      - pulse_meter.set_total_pulses:
          id: sensor_energy_pulse_meter_imported
          value: 0

# Sensors for ESP version and WIFI information
text_sensor:
  - platform: version
    hide_timestamp: true
    name: '${friendly_name} - ESPHome Version'
  - platform: wifi_info
    ip_address:
      name: '${friendly_name} - IP Address'
      icon: mdi:wifi
    ssid:
      name: '${friendly_name} - Connected SSID'
      icon: mdi:wifi-strength-2

# Binary sensor toggle for counting pulses
binary_sensor:
  - platform: gpio
    id: import_count_raw
    pin: ${ipulse_pin}
    on_state:
      then:
        - switch.toggle: ipin

switch:
  - platform: gpio
    id: ipin
    pin: 18
    
sensor:
  # WiFi signal
  - platform: wifi_signal
    name: "${friendly_name} - WiFi Signal"
    update_interval: 120s

# IMPORTED POWER
  - platform: pulse_meter
    name: '${friendly_name} - Power Imported'
    id: sensor_energy_pulse_meter_imported
    unit_of_measurement: 'W'
    internal_filter: 3us
    state_class: measurement
    device_class: power
    icon: mdi:flash-outline
    timeout: 15s
    accuracy_decimals: 0
    pin: 19
    filters:
      - lambda: return x * ((60.0 / ${pulse_rate}) * 1000.0);
    total:
      name: '${friendly_name} - Total Energy (Imported)'
      id: sensor_total_energy_imported
      unit_of_measurement: 'kWh'
      icon: mdi:circle-slice-3
      state_class: total_increasing
      device_class: energy
      accuracy_decimals: 3
      filters:
        - lambda: return x * (1.0 / ${pulse_rate});

  - platform: total_daily_energy
    name: '${friendly_name} - Daily Energy (Imported)'
    id: sensor_total_daily_energy_imported
    power_id: sensor_energy_pulse_meter_imported
    unit_of_measurement: 'kWh'
    icon: mdi:circle-slice-3
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 3
    filters:
      # Multiplication factor from W to kW is 0.001
      - multiply: 0.001

#  CT SENSOR
  - platform: adc
    pin: 35
    id: adc_sensor_1
    attenuation: auto
    accuracy_decimals: 5

  - platform: ct_clamp
    sensor: adc_sensor_1
    name: "CT Sensor 1 Raw"
    update_interval: 1s
    accuracy_decimals: 6
    
  - platform: ct_clamp
    sensor: adc_sensor_1
    name: "CT Sensor 1 Measured"
    internal: True
    update_interval: 1s
    #sample_duration: 1s
    filters:
      - calibrate_linear:
            - 0.021 -> 0.00  #0w
            - 0.147 -> 1.97  #473W
            - 0.178 -> 3.83  #920W
            - 0.222 -> 5.42  #1301W
            - 0.251 -> 6.22  #1493W
            - 0.272 -> 7.13  #1711W
            - 0.312 -> 8.475 #2034W
            - 0.367 -> 10.10 #2425W
            - 0.417 -> 11.92 #2861W
            - 0.468 -> 13.58 #3260W
            - 0.515 -> 15.22 #3653W
            - 0.573 -> 17.43 #4185W
            - 0.584 -> 18.86 #4526W
            - 0.590 -> 20.5  #4920w
            - 0.600 -> 20.9  #5016w
    accuracy_decimals: 5    
    id: ct1_measured_current

  - platform: template
    name: "CT Sensor 1"
    id: ct_sensor_1
    lambda: |-
      if (id(ct1_measured_current).state > 0){
        return (id(ct1_measured_current).state);
      } else {
        return 0.0;
      }
    device_class: current
    update_interval: 1s
    accuracy_decimals: 2
    unit_of_measurement: A
    filters:
    - median:
        window_size: 7
        send_every: 4
        send_first_at: 3
          
  - platform: total_daily_energy
    name: '${friendly_name} - Daily Energy (Usage)'
    id: sensor_total_daily_energy_usage
    power_id: adc_sensor_1
    unit_of_measurement: 'kWh'
    icon: mdi:circle-slice-3
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 3
    filters:
      # Multiplication factor from W to kW is 0.001
      - multiply: 0.001
      
# Enable time component to reset energy at midnight
time:
  - platform: sntp
    id: my_time
```

## Home Assistant
Now we have:
 - LED pulse monitor reading imp/kWh on the meter (I stuck this sensor to the plastic cover with some blu-tack),
 - a CT sensor reading our house consumption (I was unable to isolate just the house usage on the main breaker, as the solar was also running through that to export to grid. Instead I'm monitoring ~3 breakers in onwards, so I'm missing a few lighting/power breakers).
 - The GoodWe inverter integrated with Home Assistant and reading values every second.

**Custom sensors**
In `homeassistant.yaml` I have a line to import all files in the `sensors/` directory:
`sensor: !include_dir_merge_list  sensors/`

*config/sensors/power-monitoring.yaml*:
```
# Convert the CT reading into watts (multiply by 240v)
- platform: template
  sensors:
    ct_sensor_1_watts:
      value_template: '{{ (states("sensor.ct_sensor_1") | float * 240 | float) | round(1) }}'
      unit_of_measurement: "W"
      device_class: power

# Create kWh reading
- platform: integration
  source: sensor.ct_sensor_1_watts
  name: Power Consumption
  unit_prefix: k
  round: 4

# Calculate total consumption, return to grid, and solar provided to the house
# (includes +400W buffer for skipped breakers in breaker panel).
- platform: template
  sensors:
    house_consumption:
      value_template: >-
        {% set power = ((states("sensor.ct_sensor_1_watts") | float + 400 ) | round(1)) %}
        {{ 0 if power < 0 else power }}
      unit_of_measurement: "W"
      device_class: power
    solar_to_grid:
      value_template: >-
        {% set power = ((states("sensor.pv_power") | float - states("sensor.house_consumption") | float) | round(1)) %}
        {{ 0 if power < 0 else power }}
      unit_of_measurement: "W"
      device_class: power
    solar_to_house:
      value_template: >-
        {% set power = ((states("sensor.pv_power") | float - states("sensor.solar_to_grid") | float) | round(1)) %}
        {{ 0 if power < 0 else power }}
      unit_of_measurement: "W"
      device_class: power
    current_usage:
      value_template: >-
        {% set led_sensor = (states("sensor.energy_monitor_power_imported") | float) %}
        {% set led_solar = (states("sensor.energy_monitor_power_imported") | float + states("sensor.pv_power") | float) %}
        {% set ct_sensor = (states("sensor.ct_sensor_1_watts") | float + 400) %}
        {% set pv_sensor = (states("sensor.pv_power") | float) %}
        {{ led_sensor if pv_sensor < 0 else led_solar if led_sensor > 0 else ct_sensor }}
      unit_of_measurement: "W"
      device_class: power
- platform: integration
  source: sensor.solar_to_grid
  name: Solar to grid kWh
  unit_prefix: k
  round: 4
- platform: integration
  source: sensor.house_consumption
  name: House Consumption kWh
  unit_prefix: k
  round: 4
```

Now we have calculated the energy consumed by the house at all times (as the LED sensor only works when there is no solar). The main section from this is:
`{{ led_sensor if pv_sensor < 0 else led_solar if led_sensor > 0 else ct_sensor }}`

A break down of what this is doing:
- If there is no solar, use the value from the LDR pulse counter,
- else if there is solar but the LDR is still reading (it shouldn't be), then use value: (LDR+Solar),
- else if there is no solar and no LDR reading, use the CT sensor value.

## Node Red
We can now get to the automation part of this project. I'm using Node Red to get values from the CT, LDR, PV Inverter, and current electricity feed-in/general import costs. This flow then uses that data and limits the inverter to only generate x watts.
![](https://i.imgur.com/2OSvJQ8.png)
Node Red code:
```
[{"id":"31d0fc21a25f3c49","type":"server-state-changed","z":"faec5303aab17645","name":"CT sensor read","server":"233a9c63.e2baf4","version":4,"exposeToHomeAssistant":false,"haConfig":[{"property":"name","value":""},{"property":"icon","value":""}],"entityidfilter":"sensor.ct_sensor_1_watts","entityidfiltertype":"exact","outputinitially":false,"state_type":"str","haltifstate":"0","halt_if_type":"num","halt_if_compare":"gt","outputs":2,"output_only_on_state_change":false,"for":"0","forType":"num","forUnits":"minutes","ignorePrevStateNull":false,"ignorePrevStateUnknown":false,"ignorePrevStateUnavailable":false,"ignoreCurrentStateUnknown":false,"ignoreCurrentStateUnavailable":false,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"entityState"},{"property":"data","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"","valueType":"triggerId"}],"x":200,"y":160,"wires":[["dcc99de3ab6a4c02"],[]]},{"id":"dcc99de3ab6a4c02","type":"api-current-state","z":"faec5303aab17645","name":"If feed in >$0.00/kWh","server":"233a9c63.e2baf4","version":3,"outputs":2,"halt_if":"0.00","halt_if_type":"num","halt_if_compare":"gt","entity_id":"sensor.redactedaddress_feed_in_price","state_type":"num","blockInputOverrides":false,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"entityState"},{"property":"data","propertyType":"msg","value":"","valueType":"entity"}],"for":"0","forType":"num","forUnits":"minutes","override_topic":false,"state_location":"payload","override_payload":"msg","entity_location":"data","override_data":"msg","x":420,"y":180,"wires":[["23de6738e2931a8e"],["05223a53e0028393"]]},{"id":"48d324b7191ad7c0","type":"function","z":"faec5303aab17645","name":"Get current usage","func":"var usage = msg.payload\nmsg.payload = global.get(\"homeassistant.homeAssistant.states['sensor.current_usage'].state\");\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":370,"y":380,"wires":[["e8749d04ce5677d3"]]},{"id":"e8749d04ce5677d3","type":"change","z":"faec5303aab17645","name":"Convert string to number","rules":[{"t":"set","p":"payload","pt":"msg","to":"$number(payload)","tot":"jsonata"}],"action":"","property":"","from":"","to":"","reg":false,"x":590,"y":380,"wires":[["f3982715135bc638"]]},{"id":"f3982715135bc638","type":"api-call-service","z":"faec5303aab17645","name":"Set inverter limit based on consumption","server":"233a9c63.e2baf4","version":5,"debugenabled":false,"domain":"number","service":"set_value","areaId":[],"deviceId":["720edec02638dcf86d07e13ae6925d3e"],"entityId":["number.grid_export_limit"],"data":"{\"value\":msg.payload}","dataType":"jsonata","mergeContext":"","mustacheAltTags":false,"outputProperties":[],"queue":"none","x":880,"y":380,"wires":[["7af5fcb28ea42b40"]]},{"id":"23de6738e2931a8e","type":"api-call-service","z":"faec5303aab17645","name":"Set inverter limit to 5000W","server":"233a9c63.e2baf4","version":5,"debugenabled":false,"domain":"number","service":"set_value","areaId":[],"deviceId":["720edec02638dcf86d07e13ae6925d3e"],"entityId":["number.grid_export_limit"],"data":"{\"value\":5000}","dataType":"jsonata","mergeContext":"","mustacheAltTags":false,"outputProperties":[],"queue":"none","x":700,"y":180,"wires":[["bb8226dfa4748ce4"]]},{"id":"bb8226dfa4748ce4","type":"debug","z":"faec5303aab17645","name":"Inverter Setpoint","active":false,"tosidebar":true,"console":true,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":970,"y":180,"wires":[]},{"id":"5e6666fd7de03bf2","type":"inject","z":"faec5303aab17645","name":"Inject","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":190,"y":400,"wires":[["48d324b7191ad7c0"]]},{"id":"9a1d7715f81cefd7","type":"server-state-changed","z":"faec5303aab17645","name":"Import LED read","server":"233a9c63.e2baf4","version":4,"exposeToHomeAssistant":false,"haConfig":[{"property":"name","value":""},{"property":"icon","value":""}],"entityidfilter":"sensor.energy_monitor_power_imported","entityidfiltertype":"exact","outputinitially":false,"state_type":"str","haltifstate":"0","halt_if_type":"num","halt_if_compare":"gt","outputs":2,"output_only_on_state_change":false,"for":"0","forType":"num","forUnits":"minutes","ignorePrevStateNull":false,"ignorePrevStateUnknown":false,"ignorePrevStateUnavailable":false,"ignoreCurrentStateUnknown":false,"ignoreCurrentStateUnavailable":false,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"entityState"},{"property":"data","propertyType":"msg","value":"","valueType":"eventData"},{"property":"topic","propertyType":"msg","value":"","valueType":"triggerId"}],"x":200,"y":220,"wires":[["dcc99de3ab6a4c02"],[]]},{"id":"05223a53e0028393","type":"api-current-state","z":"faec5303aab17645","name":"If import <$0.00/kWh","server":"233a9c63.e2baf4","version":3,"outputs":2,"halt_if":"0.00","halt_if_type":"num","halt_if_compare":"lt","entity_id":"sensor.redactedaddress_general_price","state_type":"num","blockInputOverrides":false,"outputProperties":[{"property":"payload","propertyType":"msg","value":"","valueType":"entityState"},{"property":"data","propertyType":"msg","value":"","valueType":"entity"}],"for":"0","forType":"num","forUnits":"minutes","override_topic":false,"state_location":"payload","override_payload":"msg","entity_location":"data","override_data":"msg","x":460,"y":280,"wires":[["450a808083ba4b74"],["48d324b7191ad7c0"]]},{"id":"7af5fcb28ea42b40","type":"debug","z":"faec5303aab17645","name":"Inverter Setpoint","active":false,"tosidebar":true,"console":true,"tostatus":true,"complete":"true","targetType":"full","statusVal":"payload","statusType":"auto","x":1150,"y":380,"wires":[]},{"id":"450a808083ba4b74","type":"api-call-service","z":"faec5303aab17645","name":"Set inverter limit to 0W","server":"233a9c63.e2baf4","version":5,"debugenabled":false,"domain":"number","service":"set_value","areaId":[],"deviceId":["720edec02638dcf86d07e13ae6925d3e"],"entityId":["number.grid_export_limit"],"data":"{\"value\":0}","dataType":"jsonata","mergeContext":"","mustacheAltTags":false,"outputProperties":[],"queue":"none","x":720,"y":280,"wires":[["bb8226dfa4748ce4"]]},{"id":"f00ab1d08e0b1898","type":"comment","z":"faec5303aab17645","name":"If feed-in not profitable and import is, disable the solar inverter output","info":"","x":560,"y":240,"wires":[]},{"id":"d54173f8945158ff","type":"comment","z":"faec5303aab17645","name":"If feed-in profitable, let the inverter output the max","info":"","x":500,"y":140,"wires":[]},{"id":"f9142e0b6e4c8073","type":"comment","z":"faec5303aab17645","name":"If nothing is profitable, allow inverter to only generate required power","info":"","x":560,"y":340,"wires":[]},{"id":"233a9c63.e2baf4","type":"server","name":"Home Assistant","version":4,"addon":true,"rejectUnauthorizedCerts":true,"ha_boolean":"y|yes|true|on|home|open","connectionDelay":true,"cacheJson":true,"heartbeat":false,"heartbeatInterval":"30","areaSelector":"friendlyName","deviceSelector":"friendlyName","entitySelector":"friendlyName","statusSeparator":"at: ","statusYear":"hidden","statusMonth":"short","statusDay":"numeric","statusHourCycle":"h23","statusTimeFormat":"h:m"}]
```
## Result
The automation now reacts to price changes and acts accordingly to limit the solar production to only generate what's needed to cover the house usage when the feed-in price is negative, and max out the inverter when it's profitable to export to the grid.

There is logic in here to ensure that we are never importing when we have the solar to cover it, unless the cost of importing power is negative. (In which case we set the inverter to 0W and import as much as possible!).

![](https://i.imgur.com/rtPRiqv.png)
Above is an example of what the sensors look like when solar feed-in is negative. The bottom blue line is reported by the LDR, we can see spikes where we didn't have enough solar available (cloudy day) to cover the energy usage, although for the rest of it the solar generated is doing exactly what I wanted.

**What this looks like to Amber Electric**
![](https://i.imgur.com/4oM1T8a.png)
You can see when the Feed-in price is negative, I barely exported anything. Mission success.
